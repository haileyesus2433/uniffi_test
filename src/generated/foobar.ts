// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './foobar-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export function quickPalindromeCheck(text: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_quick_palindrome_check(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function quickReverseText(text: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_quick_reverse_text(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function quickWordCount(text: string): /*u32*/ number {
  return FfiConverterUInt32.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_quick_word_count(
          FfiConverterString.lower(text),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type TextAnalysisResult = {
  originalText: string;
  characterCount: /*u32*/ number;
  wordCount: /*u32*/ number;
  sentenceCount: /*u32*/ number;
  paragraphCount: /*u32*/ number;
  isPalindrome: boolean;
  reversedText: string;
  uppercaseText: string;
  lowercaseText: string;
  titleCaseText: string;
  vowelCount: /*u32*/ number;
  consonantCount: /*u32*/ number;
  mostCommonWord: string;
  mostCommonWordCount: /*u32*/ number;
};

/**
 * Generated factory for {@link TextAnalysisResult} record objects.
 */
export const TextAnalysisResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TextAnalysisResult, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TextAnalysisResult}, with defaults specified
     * in Rust, in the {@link foobar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TextAnalysisResult}, with defaults specified
     * in Rust, in the {@link foobar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link foobar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TextAnalysisResult>,
  });
})();

const FfiConverterTypeTextAnalysisResult = (() => {
  type TypeName = TextAnalysisResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        originalText: FfiConverterString.read(from),
        characterCount: FfiConverterUInt32.read(from),
        wordCount: FfiConverterUInt32.read(from),
        sentenceCount: FfiConverterUInt32.read(from),
        paragraphCount: FfiConverterUInt32.read(from),
        isPalindrome: FfiConverterBool.read(from),
        reversedText: FfiConverterString.read(from),
        uppercaseText: FfiConverterString.read(from),
        lowercaseText: FfiConverterString.read(from),
        titleCaseText: FfiConverterString.read(from),
        vowelCount: FfiConverterUInt32.read(from),
        consonantCount: FfiConverterUInt32.read(from),
        mostCommonWord: FfiConverterString.read(from),
        mostCommonWordCount: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.originalText, into);
      FfiConverterUInt32.write(value.characterCount, into);
      FfiConverterUInt32.write(value.wordCount, into);
      FfiConverterUInt32.write(value.sentenceCount, into);
      FfiConverterUInt32.write(value.paragraphCount, into);
      FfiConverterBool.write(value.isPalindrome, into);
      FfiConverterString.write(value.reversedText, into);
      FfiConverterString.write(value.uppercaseText, into);
      FfiConverterString.write(value.lowercaseText, into);
      FfiConverterString.write(value.titleCaseText, into);
      FfiConverterUInt32.write(value.vowelCount, into);
      FfiConverterUInt32.write(value.consonantCount, into);
      FfiConverterString.write(value.mostCommonWord, into);
      FfiConverterUInt32.write(value.mostCommonWordCount, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.originalText) +
        FfiConverterUInt32.allocationSize(value.characterCount) +
        FfiConverterUInt32.allocationSize(value.wordCount) +
        FfiConverterUInt32.allocationSize(value.sentenceCount) +
        FfiConverterUInt32.allocationSize(value.paragraphCount) +
        FfiConverterBool.allocationSize(value.isPalindrome) +
        FfiConverterString.allocationSize(value.reversedText) +
        FfiConverterString.allocationSize(value.uppercaseText) +
        FfiConverterString.allocationSize(value.lowercaseText) +
        FfiConverterString.allocationSize(value.titleCaseText) +
        FfiConverterUInt32.allocationSize(value.vowelCount) +
        FfiConverterUInt32.allocationSize(value.consonantCount) +
        FfiConverterString.allocationSize(value.mostCommonWord) +
        FfiConverterUInt32.allocationSize(value.mostCommonWordCount)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: TextAnalysisError

// Enum: TextAnalysisError
export enum TextAnalysisError_Tags {
  EmptyText = 'EmptyText',
  TextTooLong = 'TextTooLong',
}
export const TextAnalysisError = (() => {
  type EmptyText__interface = {
    tag: TextAnalysisError_Tags.EmptyText;
  };

  class EmptyText_ extends UniffiError implements EmptyText__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TextAnalysisError';
    readonly tag = TextAnalysisError_Tags.EmptyText;
    constructor() {
      super('TextAnalysisError', 'EmptyText');
    }

    static new(): EmptyText_ {
      return new EmptyText_();
    }

    static instanceOf(obj: any): obj is EmptyText_ {
      return obj.tag === TextAnalysisError_Tags.EmptyText;
    }

    static hasInner(obj: any): obj is EmptyText_ {
      return false;
    }
  }

  type TextTooLong__interface = {
    tag: TextAnalysisError_Tags.TextTooLong;
  };

  class TextTooLong_ extends UniffiError implements TextTooLong__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TextAnalysisError';
    readonly tag = TextAnalysisError_Tags.TextTooLong;
    constructor() {
      super('TextAnalysisError', 'TextTooLong');
    }

    static new(): TextTooLong_ {
      return new TextTooLong_();
    }

    static instanceOf(obj: any): obj is TextTooLong_ {
      return obj.tag === TextAnalysisError_Tags.TextTooLong;
    }

    static hasInner(obj: any): obj is TextTooLong_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is TextAnalysisError {
    return obj[uniffiTypeNameSymbol] === 'TextAnalysisError';
  }

  return Object.freeze({
    instanceOf,
    EmptyText: EmptyText_,
    TextTooLong: TextTooLong_,
  });
})();

export type TextAnalysisError = InstanceType<
  (typeof TextAnalysisError)[keyof Omit<typeof TextAnalysisError, 'instanceOf'>]
>;

// FfiConverter for enum TextAnalysisError
const FfiConverterTypeTextAnalysisError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TextAnalysisError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TextAnalysisError.EmptyText();
        case 2:
          return new TextAnalysisError.TextTooLong();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TextAnalysisError_Tags.EmptyText: {
          ordinalConverter.write(1, into);
          return;
        }
        case TextAnalysisError_Tags.TextTooLong: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that TextAnalysisError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TextAnalysisError_Tags.EmptyText: {
          return ordinalConverter.allocationSize(1);
        }
        case TextAnalysisError_Tags.TextTooLong: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Text Analyzer - A powerful text analysis tool
 */
export interface TextAnalyzerInterface {
  /**
   * Analyze text and return comprehensive analysis results
   */
  analyzeText(text: string) /*throws*/ : TextAnalysisResult;
  /**
   * Clear analysis history
   */
  clearHistory(): void;
  /**
   * Get the last analysis result
   */
  getLastAnalysis(): TextAnalysisResult | undefined;
}

/**
 * Text Analyzer - A powerful text analysis tool
 */
export class TextAnalyzer
  extends UniffiAbstractObject
  implements TextAnalyzerInterface
{
  readonly [uniffiTypeNameSymbol] = 'TextAnalyzer';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_constructor_textanalyzer_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeTextAnalyzerObjectFactory.bless(pointer);
  }

  /**
   * Analyze text and return comprehensive analysis results
   */
  public analyzeText(text: string): TextAnalysisResult /*throws*/ {
    return FfiConverterTypeTextAnalysisResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeTextAnalysisError.lift.bind(
          FfiConverterTypeTextAnalysisError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_foobar_fn_method_textanalyzer_analyze_text(
            uniffiTypeTextAnalyzerObjectFactory.clonePointer(this),
            FfiConverterString.lower(text),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Clear analysis history
   */
  public clearHistory(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_foobar_fn_method_textanalyzer_clear_history(
          uniffiTypeTextAnalyzerObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the last analysis result
   */
  public getLastAnalysis(): TextAnalysisResult | undefined {
    return FfiConverterOptionalTypeTextAnalysisResult.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_foobar_fn_method_textanalyzer_get_last_analysis(
            uniffiTypeTextAnalyzerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeTextAnalyzerObjectFactory.pointer(this);
      uniffiTypeTextAnalyzerObjectFactory.freePointer(pointer);
      uniffiTypeTextAnalyzerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is TextAnalyzer {
    return uniffiTypeTextAnalyzerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeTextAnalyzerObjectFactory: UniffiObjectFactory<TextAnalyzerInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): TextAnalyzerInterface {
        const instance = Object.create(TextAnalyzer.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'TextAnalyzer';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_textanalyzer_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: TextAnalyzerInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: TextAnalyzerInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_foobar_fn_clone_textanalyzer(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_foobar_fn_free_textanalyzer(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is TextAnalyzerInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'TextAnalyzer'
        );
      },
    };
  })();
// FfiConverter for TextAnalyzerInterface
const FfiConverterTypeTextAnalyzer = new FfiConverterObject(
  uniffiTypeTextAnalyzerObjectFactory
);

// FfiConverter for TextAnalysisResult | undefined
const FfiConverterOptionalTypeTextAnalysisResult = new FfiConverterOptional(
  FfiConverterTypeTextAnalysisResult
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_foobar_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_quick_palindrome_check() !==
    36863
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_quick_palindrome_check'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_quick_reverse_text() !==
    57858
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_quick_reverse_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_quick_word_count() !== 2601
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_quick_word_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_method_textanalyzer_analyze_text() !==
    12978
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_method_textanalyzer_analyze_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_method_textanalyzer_clear_history() !==
    54998
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_method_textanalyzer_clear_history'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_method_textanalyzer_get_last_analysis() !==
    65455
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_method_textanalyzer_get_last_analysis'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_constructor_textanalyzer_new() !==
    17889
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_constructor_textanalyzer_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeTextAnalysisResult,
    FfiConverterTypeTextAnalyzer,
  },
});
